<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>translate_tts – Hosted-Robust One-Click</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
<h1>Unofficial translate_tts – Robust Demo</h1>

<label for="lang">Language code (ar, en, fr…)</label><br>
<input id="lang" type="text" value="ar" style="width:140px;" /><br><br>

<label for="text">Text</label><br>
<textarea id="text" rows="5" style="width:100%;">السلام عليكم ورحمة الله وبركاته</textarea><br><br>

<button id="play">🔊 Play</button>
<button id="stop">⏹ Stop</button>
<span id="status" aria-live="polite" style="margin-left:8px;"></span>

<div style="margin-top:10px;">
  <audio id="audio" playsinline preload="auto" controls style="width:100%;" crossorigin="anonymous"></audio>
</div>
<p>
  If playback still fails, press ▶️ on the player or
  <a id="openTab" href="#" target="_blank" rel="noopener">open audio in a new tab</a>.
</p>

<a href="https://quasi-quarks.github.io/quasiquarks/audioarab2/audioarabic9.html" download="audioarabic9.html">audioarabic8.html</a>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const langEl = $('#lang');
  const textEl = $('#text');
  const playBtn = $('#play');
  const stopBtn = $('#stop');
  const audio = $('#audio');
  const statusEl = $('#status');
  const openTab = $('#openTab');

  let unlocked = false;
  let ac = null;

  function setStatus(msg){ statusEl.textContent = msg || ''; }

  function chunkText(text, maxLen = 180) {
    const parts = [];
    let t = text.trim();
    while (t.length > maxLen) {
      let cut = t.lastIndexOf(' ', maxLen);
      if (cut === -1) cut = maxLen;
      parts.push(t.slice(0, cut));
      t = t.slice(cut).trim();
    }
    if (t) parts.push(t);
    return parts;
  }

  function buildTTSUrl(q, tl, client = 'gtx') {
    const params = new URLSearchParams({
      ie: 'UTF-8',
      q,
      tl,
      client
    });
    // cache-bust + encourage byte-range friendliness
    params.append('_', Date.now().toString());
    return 'https://translate.googleapis.com/translate_tts?' + params.toString();
  }

  async function unlockAudioOnce() {
    if (unlocked) return;
    try {
      ac = ac || new (window.AudioContext || window.webkitAudioContext)();
      if (ac.state === 'suspended') await ac.resume();
      const buf = ac.createBuffer(1, 1, 44100);
      const src = ac.createBufferSource();
      src.buffer = buf; src.connect(ac.destination); src.start(0);
    } catch {}
    try {
      audio.muted = true;
      audio.src = 'data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA';
      await audio.play().catch(()=>{});
      audio.pause(); audio.currentTime = 0; audio.muted = false;
    } catch {}
    unlocked = true;
    setStatus('Audio unlocked.');
  }

  function waitForCanPlay(el, timeoutMs = 2000) {
    return new Promise((resolve, reject) => {
      let to = setTimeout(() => {
        cleanup();
        reject(new Error('canplay timeout'));
      }, timeoutMs);
      const onCanPlay = () => { cleanup(); resolve(); };
      const onErr = (e) => { cleanup(); reject(e || new Error('audio error')); };
      function cleanup() {
        clearTimeout(to);
        el.removeEventListener('canplay', onCanPlay);
        el.removeEventListener('error', onErr);
      }
      el.addEventListener('canplay', onCanPlay, { once: true });
      el.addEventListener('error', onErr, { once: true });
      // Force load
      try { el.load(); } catch {}
    });
  }

  async function tryDirectUrlPlay(url) {
    audio.pause();
    audio.removeAttribute('src'); // reset pipeline
    audio.src = url;
    openTab.href = url;
    // Wait until decoders say it's playable
    await waitForCanPlay(audio, 2500);
    await audio.play();
  }

  async function tryBlobPlay(url) {
    // Some hosts/origins balk at direct media src; fetching to blob sidesteps it.
    // Use no-referrer to look more like a direct navigation.
    const res = await fetch(url, {
      referrerPolicy: 'no-referrer',
      // IMPORTANT: do NOT set mode:'no-cors' (you can't read the body then)
      // CORS for media is usually allowed from this endpoint; if blocked, this will throw.
    });
    if (!res.ok) throw new Error('HTTP '+res.status);
    const blob = await res.blob(); // should be audio/mpeg
    const objUrl = URL.createObjectURL(blob);

    audio.pause();
    audio.removeAttribute('src');
    audio.src = objUrl;
    openTab.href = objUrl; // still give user a way to open
    await waitForCanPlay(audio, 2500);
    await audio.play();

    // Revoke later to avoid leaks (after playing current chunk)
    audio.addEventListener('ended', () => URL.revokeObjectURL(objUrl), { once: true });
  }

  async function playOneChunk(text, tl) {
    // Try client=gtx first, then tw-ob
    const urls = [
      buildTTSUrl(text, tl, 'gtx'),
      buildTTSUrl(text, tl, 'tw-ob')
    ];

    // Strategy A: direct url
    for (const u of urls) {
      try {
        await tryDirectUrlPlay(u);
        return;
      } catch (e) {
        // fallthrough
      }
    }
    // Strategy B: fetch as blob
    for (const u of urls) {
      try {
        await tryBlobPlay(u);
        return;
      } catch (e) {
        // fallthrough
      }
    }
    throw new Error('All playback strategies failed for this chunk.');
  }

  async function playSequence(parts, tl) {
    for (let i = 0; i < parts.length; i++) {
      setStatus(`Loading ${i+1}/${parts.length}…`);
      try {
        await playOneChunk(parts[i], tl);
        setStatus(`Playing ${i+1}/${parts.length}…`);
        // Wait for this chunk to end
        await new Promise((resolve, reject) => {
          const onEnd = () => { cleanup(); resolve(); };
          const onErr = (e) => { cleanup(); reject(e || new Error('audio error')); };
          function cleanup() {
            audio.removeEventListener('ended', onEnd);
            audio.removeEventListener('error', onErr);
          }
          audio.addEventListener('ended', onEnd, { once: true });
          audio.addEventListener('error', onErr, { once: true });
        });
      } catch (e) {
        setStatus('Autoplay blocked or media load failed. Press ▶️ or Open in new tab.');
        // Stop sequence here; user can press ▶️ manually on current chunk.
        return;
      }
    }
    setStatus('Done.');
  }

  playBtn.addEventListener('click', async () => {
    const tl = (langEl.value || 'ar').trim();
    const text = textEl.value.trim();
    if (!text) { setStatus('Enter some text.'); return; }

    await unlockAudioOnce(); // Same-gesture unlock
    const parts = chunkText(text);
    if (parts.length === 0) { setStatus('Enter some text.'); return; }

    try {
      await playSequence(parts, tl);
    } catch (e) {
      console.error(e);
      setStatus('Playback error. Try ▶️ or Open in new tab.');
    }
  });

  stopBtn.addEventListener('click', () => {
    audio.pause();
    setStatus('Stopped.');
  });
})();
</script>
</body>
</html>
