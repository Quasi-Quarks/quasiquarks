<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>TTS Demo â€” Feels Local via Service Worker</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<!-- Optional warm-ups -->
<link rel="preconnect" href="https://translate.googleapis.com">
</head>
<body>
<h1>Unofficial translate_tts â€” Local-like (SW)</h1>

<label>Language</label><br>
<input id="lang" value="ar" style="width:120px"><br><br>

<label>Text</label><br>
<textarea id="text" rows="5" style="width:100%;">Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ… ÙˆØ±Ø­Ù…Ø© Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø±ÙƒØ§ØªÙ‡</textarea><br><br>

<button id="play">ğŸ”Š Play</button>
<button id="stop">â¹ Stop</button>
<span id="status" style="margin-left:8px;"></span>

<div style="margin-top:10px;">
  <audio id="audio" playsinline preload="auto" controls style="width:100%;"></audio>
</div>

<script>
// --- Register Service Worker (must be HTTPS or localhost) ---
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(console.warn);
}

(() => {
  const $ = s => document.querySelector(s);
  const langEl = $('#lang');
  const textEl = $('#text');
  const playBtn = $('#play');
  const stopBtn = $('#stop');
  const audio = $('#audio');
  const statusEl = $('#status');

  let unlocked = false;
  let ac = null;

  function setStatus(m){ statusEl.textContent = m || ''; }

  function chunkText(text, max=180){
    const out=[]; let t=text.trim();
    while (t.length>max) { let cut=t.lastIndexOf(' ',max); if(cut<0) cut=max; out.push(t.slice(0,cut)); t=t.slice(cut).trim(); }
    if (t) out.push(t);
    return out;
  }

  // Now build a SAME-ORIGIN URL that SW will fulfill
  function localTTSUrl(q, tl, client='gtx'){
    const u = new URL('/local-tts', location.origin);
    u.searchParams.set('q', q);
    u.searchParams.set('tl', tl);
    u.searchParams.set('client', client);
    u.searchParams.set('_', Date.now().toString());
    return u.toString();
  }

  async function unlockAudioOnce(){
    if (unlocked) return;
    try {
      ac = ac || new (window.AudioContext||window.webkitAudioContext)();
      if (ac.state === 'suspended') await ac.resume();
      const b = ac.createBuffer(1, 1, 44100), s = ac.createBufferSource();
      s.buffer = b; s.connect(ac.destination); s.start(0);
    } catch {}
    try {
      audio.muted = true;
      audio.src = 'data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA';
      await audio.play().catch(()=>{});
      audio.pause(); audio.currentTime = 0; audio.muted = false;
    } catch {}
    unlocked = true;
    setStatus('Audio unlocked.');
  }

  function waitForCanPlay(el, ms=2500){
    return new Promise((resolve, reject)=>{
      const to = setTimeout(()=>{cleanup(); reject(new Error('canplay timeout'))}, ms);
      const ok = ()=>{cleanup(); resolve();};
      const er = (e)=>{cleanup(); reject(e||new Error('audio error'));};
      function cleanup(){ clearTimeout(to); el.removeEventListener('canplay', ok); el.removeEventListener('error', er); }
      el.addEventListener('canplay', ok, {once:true});
      el.addEventListener('error', er, {once:true});
      try { el.load(); } catch {}
    });
  }

  async function tryDirect(url){
    audio.pause(); audio.removeAttribute('src');
    audio.src = url;
    await waitForCanPlay(audio, 3500);
    await audio.play();
  }

  async function tryBlob(url){
    const r = await fetch(url, { referrerPolicy:'no-referrer' });
    if (!r.ok) throw new Error('HTTP '+r.status);
    const blob = await r.blob();
    const obj = URL.createObjectURL(blob);
    audio.pause(); audio.removeAttribute('src');
    audio.src = obj;
    await waitForCanPlay(audio, 3500);
    await audio.play();
    audio.addEventListener('ended', ()=> URL.revokeObjectURL(obj), {once:true});
  }

  async function playOneChunk(text, tl){
    const urls = [
      localTTSUrl(text, tl, 'gtx'),
      localTTSUrl(text, tl, 'tw-ob'),
    ];
    for (const u of urls){ try { await tryDirect(u); return; } catch(e){} }
    for (const u of urls){ try { await tryBlob(u);   return; } catch(e){} }
    // Ultimate fallback: new tab
    window.open(urls[0], '_blank', 'noopener');
    throw new Error('Opened in new tab fallback.');
  }

  async function playSequence(parts, tl){
    for (let i=0;i<parts.length;i++){
      setStatus(`Loading ${i+1}/${parts.length}â€¦`);
      try {
        await playOneChunk(parts[i], tl);
        setStatus(`Playing ${i+1}/${parts.length}â€¦`);
        await new Promise((res, rej)=>{
          const end=()=>{cleanup(); res();};
          const err=(e)=>{cleanup(); rej(e||new Error('audio error'));};
          function cleanup(){ audio.removeEventListener('ended', end); audio.removeEventListener('error', err); }
          audio.addEventListener('ended', end, {once:true});
          audio.addEventListener('error', err, {once:true});
        });
      } catch(e){
        setStatus('Playback blocked/failed. Use â–¶ï¸ or new tab.');
        return;
      }
    }
    setStatus('Done.');
  }

  playBtn.addEventListener('click', async ()=>{
    const tl = (langEl.value||'ar').trim();
    const text = textEl.value.trim();
    if (!text) { setStatus('Enter some text.'); return; }

    await unlockAudioOnce(); // in same gesture
    const parts = chunkText(text);
    try { await playSequence(parts, tl); }
    catch(e){ console.warn(e); setStatus('Fallback used.'); }
  });

  stopBtn.addEventListener('click', ()=>{ audio.pause(); setStatus('Stopped.'); });
})();
</script>
</body>
</html>
