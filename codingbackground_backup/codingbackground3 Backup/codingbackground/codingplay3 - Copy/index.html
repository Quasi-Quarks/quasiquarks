<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mobile First ‚Äì 20% Menu / 80% Body + Mini Editor</title>
  <link rel="stylesheet" href="index5.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>

<body class="state-compact">
  <!-- 3-state toggle: Hidden ‚Üí 20% ‚Üí 100% -->
  <button id="menudisplay" aria-label="Toggle menu">‚ò∞</button>

  <!-- Left menu -->
  <nav class="menuBarstdy" aria-label="Study Menu">
    <div class="menuHeader">
      <div class="menuTitle">Study Menu</div>
    </div>

    <div class="menustudycategorycontainer open">
      <button class="menustudycategory" aria-expanded="true">
        <span class="menustudytxtheader">Set up</span>
        <svg class="chev" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>
      </button>
      <div class="menustudy" role="region" aria-label="Set up">
        <a class="menustudytxt" href="#">Set up</a>
        <a class="menustudytxt" href="#">Set up on desktop</a>
        <a class="menustudytxt" href="#">Set up on android</a>
        <a class="menustudytxt" href="#">Set up on iphone</a>
      </div>
    </div>

    <div class="menustudycategorycontainer">
      <button class="menustudycategory" aria-expanded="false">
        <span class="menustudytxtheader">What is HTML?</span>
        <svg class="chev" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>
      </button>
      <div class="menustudy" role="region" aria-label="What is HTML?">
        <a class="menustudytxt" href="#">Overview</a>
        <a class="menustudytxt" href="#">Elements & Tags</a>
        <a class="menustudytxt" href="#">Attributes</a>
        <a class="menustudytxt" href="#">Semantic HTML</a>
      </div>
    </div>

    <div class="menustudycategorycontainer">
      <button class="menustudycategory" aria-expanded="false">
        <span class="menustudytxtheader">How to learn</span>
        <svg class="chev" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>
      </button>
      <div class="menustudy" role="region" aria-label="How to learn">
        <a class="menustudytxt" href="#">Roadmap</a>
        <a class="menustudytxt" href="#">Practice</a>
        <a class="menustudytxt" href="#">Projects</a>
        <a class="menustudytxt" href="#">Resources</a>
      </div>
    </div>
  </nav>

  <!-- Main content (80%) -->
  <main class="mainbody" role="main">
    <div class="body_container_cover">
      <div class="body_container">

        <div class="body_container_cover_section_cover">
          <div class="section_container">
            <h1>We'll get right into it</h1>
            <p>This course gives you enough to start working, freelancing, or building a business. We‚Äôll guide you along the way.</p>
          </div>
        </div>

        <!-- ===== Minimal two-textarea editor block ===== -->
        <div class="body_container_cover_section_cover menu_editor">
          <h2>Mini Editor</h2>

          <div class="editor_controls">
            <button id="btnLoad">üìÇ Load JSON‚Ä¶</button>
            <input id="fileJson" type="file" accept=".json,application/json" style="display:none">
            <button id="btnPlay">‚ñ∂ Play</button>
            <button id="btnPause">‚ùö‚ùö Pause</button>
            <button id="btnReset">‚Ü∫ Reset</button>
            <span id="status" style="margin-left:auto;font-size:.9rem;opacity:.8">Trying to auto-load recording.json‚Ä¶</span>
          </div>

          <div style="font-size:.9rem; color:#bbb; margin-bottom:6px;">src ¬∑ play ¬∑ pause ¬∑ edit ¬∑ output</div>

          <!-- Readonly wrapper (shown only while playing) -->
          <div id="roWrap">
            <label>Read-only (timeline)</label>
            <textarea id="txtReadonly" readonly></textarea>
          </div>

          <!-- Editable wrapper (shown only while paused) -->
          <div id="editWrap">
            <label>Editable (your scratch)</label>
            <textarea id="txtEdit" class="editable"></textarea>
          </div>

          <div class="editor_output">
            <iframe id="outputFrame" sandbox="allow-scripts"></iframe>
          </div>
        </div>

        <div class="body_container_cover_section_cover">
          <div class="section_container">
            <h1>How to Study</h1>
            <p>Study by phone and laptop/PC. Aim for 4‚Äì5 hours a day across setup, learning, practice, fixing bugs, and building small sites.</p>
          </div>
        </div>

      </div>
    </div>
  </main>

  <script>
    /* ===== 3-state menu toggle (Hidden ‚Üí 20% ‚Üí 100%) ===== */
    (() => {
      const body = document.body;
      const btn = document.getElementById('menudisplay');
      const states = ['hidden','compact','full'];

      const current = Array.from(body.classList).find(c => c.startsWith('state-')) || 'state-compact';
      let idx = Math.max(0, states.indexOf(current.replace('state-','')));
      if (idx === -1) idx = 1;

      const apply = () => {
        states.forEach(s => body.classList.remove('state-' + s));
        body.classList.add('state-' + states[idx]);
        btn.setAttribute('aria-label', `Menu: ${states[idx]}. Tap to change`);
        btn.title = `Menu: ${states[idx]}`;
      };
      apply();

      btn.addEventListener('click', () => {
        idx = (idx + 1) % states.length;
        apply();
      });

      // Keyboard: M to cycle, Esc to hide
      window.addEventListener('keydown', (e) => {
        if (!e.metaKey && !e.ctrlKey && !e.altKey) {
          const k = e.key.toLowerCase();
          if (k === 'm') { idx = (idx + 1) % states.length; apply(); }
          if (k === 'escape') { idx = 0; apply(); }
        }
      });
    })();

    /* ===== Collapsible categories ===== */
    (() => {
      const groups = document.querySelectorAll('.menustudycategorycontainer');
      groups.forEach(group => {
        const headerBtn = group.querySelector('.menustudycategory');
        const panel = group.querySelector('.menustudy');

        const toggle = () => {
          const isOpen = group.classList.toggle('open');
          headerBtn.setAttribute('aria-expanded', String(isOpen));
          if (isOpen) {
            const firstLink = panel.querySelector('a');
            if (firstLink) firstLink.focus({ preventScroll: true });
          }
        };

        headerBtn.addEventListener('click', (e) => { e.preventDefault(); toggle(); });
        headerBtn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
        });
      });
    })();

    /* ===== Two-textarea editor + JSON playback (with autoload) ===== */
    (() => {
      const txtReadonly = document.getElementById("txtReadonly");
      const txtEdit     = document.getElementById("txtEdit");
      const roWrap      = document.getElementById("roWrap");
      const editWrap    = document.getElementById("editWrap");
      const frame       = document.getElementById("outputFrame");

      const btnLoad     = document.getElementById("btnLoad");
      const fileJson    = document.getElementById("fileJson");
      const btnPlay     = document.getElementById("btnPlay");
      const btnPause    = document.getElementById("btnPause");
      const btnReset    = document.getElementById("btnReset");
      const statusEl    = document.getElementById("status");

      let playing   = false;
      let timer     = null;
      let events    = [];     // Array of { time, change:{from,to,text[],removed[]} }
      let idx       = 0;      // next event index
      let initial   = "";     // optional initial text (if present)
      let currentTop = "";    // internal mirror of readonly content

      const setStatus = (msg) => statusEl.textContent = msg;

      function showReadonlyView(){
        roWrap.style.display = "";
        editWrap.style.display = "none";
      }
      function showEditableView(){
        roWrap.style.display = "none";
        editWrap.style.display = "";
      }

      function render(src) {
        frame.srcdoc = src || "";
      }

      // Convert {line, ch} to flat string offset against current text
      function posToOffset(text, pos) {
        const lines = text.split("\n");
        let offset = 0;
        const L = Math.max(0, Math.min(pos.line || 0, lines.length - 1));
        for (let i = 0; i < L; i++) offset += lines[i].length + 1;
        const ch = Math.max(0, Math.min(pos.ch || 0, (lines[L] || "").length));
        return offset + ch;
      }
      // Apply a CodeMirror-style change object to a plain string
      function applyChangeToText(text, chg) {
        const from = posToOffset(text, (chg && chg.from) || {line:0, ch:0});
        const to   = posToOffset(text, (chg && chg.to)   || {line:0, ch:0});
        const insert = (chg && chg.text ? chg.text.join("\n") : "");
        return text.slice(0, from) + insert + text.slice(to);
      }

      function startFromBeginning() {
        currentTop = initial || "";
        txtReadonly.value = currentTop;     // top (canonical)
        txtEdit.value     = currentTop;     // bottom synced once
        render(currentTop);
        idx = 0;
      }

      function scheduleNext() {
        if (idx >= events.length) {
          playing = false;
          setStatus("Done. Reached end of recording.");
          render(currentTop);
          showReadonlyView(); // remain in readonly view at end
          return;
        }
        const prevTime = (idx === 0) ? 0 : (events[idx-1].time || 0);
        const nextTime = (events[idx].time || 0);
        const delta = Math.max(0, nextTime - prevTime);

        timer = setTimeout(() => {
          const ev = events[idx];
          currentTop = applyChangeToText(currentTop, ev.change || {});
          txtReadonly.value = currentTop;
          // While playing, preview uses readonly
          render(currentTop);

          idx++;
          scheduleNext();
        }, delta);
      }

      function play() {
        if (!events.length) {
          setStatus("Load a JSON recording first.");
          alert("Load a JSON recording first.");
          return;
        }
        if (playing) return;
        playing = true;

        // Reset from start if first play or readonly is empty
        if (idx === 0 || txtReadonly.value === "") startFromBeginning();

        // On Play: show only readonly and keep preview from top
        txtEdit.value = txtReadonly.value; // sync once (no branching)
        showReadonlyView();
        render(txtReadonly.value);
        setStatus(`Playing‚Ä¶ (${idx}/${events.length})`);
        scheduleNext();
      }

      function pause() {
        if (timer) { clearTimeout(timer); timer = null; }
        if (playing) {
          playing = false;
          // Sync bottom with latest top once
          txtEdit.value = txtReadonly.value;
          setStatus("Paused.");
        } else {
          // Already paused; still sync and show edit view
          txtEdit.value = txtReadonly.value;
          setStatus("Paused.");
        }
        // On Pause: show only editable and preview follows it live
        showEditableView();
        render(txtEdit.value);
      }

      function reset() {
        if (timer) { clearTimeout(timer); timer = null; }
        playing = false;
        idx = 0;
        txtReadonly.value = "";
        txtEdit.value = "";
        render("");
        showEditableView();
        setStatus(events.length ? "Reset. JSON loaded; press Play to start." : "Reset. No JSON loaded.");
      }

      // Load JSON from file input
      btnLoad.addEventListener("click", () => fileJson.click());
      fileJson.addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const data = JSON.parse(reader.result);
            if (Array.isArray(data)) {
              events = data; initial = "";
            } else if (data && Array.isArray(data.events)) {
              events = data.events; initial = data.initial || "";
            } else {
              throw new Error("Unsupported JSON format.");
            }
            // Reset editors; wait for Play to reconstruct
            idx = 0; txtReadonly.value = ""; txtEdit.value = ""; render("");
            showEditableView();
            setStatus(`Loaded "${file.name}" with ${events.length} events. Press Play.`);
          } catch (err) {
            console.error(err);
            setStatus("Invalid JSON file.");
            alert("Invalid JSON file.");
          }
        };
        reader.readAsText(file);
        e.target.value = ""; // allow reselecting same file later
      });

      // Autoload recording.json (or ?src=)
      async function autoLoad() {
        const params = new URLSearchParams(location.search);
        const src = params.get('src') || 'recording.json';
        try {
          const res = await fetch(src, { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          if (Array.isArray(data)) {
            events = data; initial = "";
          } else if (data && Array.isArray(data.events)) {
            events = data.events; initial = data.initial || "";
          } else {
            throw new Error("Unsupported JSON format.");
          }
          // Don‚Äôt populate editors yet; Play will reconstruct from scratch
          idx = 0; txtReadonly.value = ""; txtEdit.value = ""; render("");
          showEditableView();
          setStatus(`Auto-loaded ${src} with ${events.length} events. Press Play.`);
        } catch (err) {
          // Likely blocked when opened via file:// or missing file
          setStatus(`Couldn‚Äôt auto-load ${src}. Use ‚ÄúLoad JSON‚Ä¶‚Äù (or serve over http).`);
        }
      }

      // Buttons
      btnPlay.addEventListener("click", play);
      btnPause.addEventListener("click", pause);
      btnReset.addEventListener("click", reset);

      // Live preview while paused (editable textarea)
      txtEdit.addEventListener("input", () => {
        if (!playing) render(txtEdit.value);
      });

      // Initial state: paused view, empty editors, try autoload
      showEditableView();
      render("");
      setStatus("Trying to auto-load recording.json‚Ä¶");
      autoLoad();
    })();
  </script>
</body>
</html>
